# -*- coding: utf-8 -*-
"""chronic kidney disease.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1luAinpn9LDyaavRstqSReiVbjqbTgazt
"""

import pandas as pd
import numpy as np
from collections import Counter as c
import matplotlib.pyplot as plt
import seaborn as sns
import missingno as msno
from sklearn.metrics import accuracy_score, confusion_matrix
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder
from sklearn.linear_model import LogisticRegression
import pickle

"""#Read The Dataset"""

data=pd.read_csv("/content/kidney_disease.csv")
data.head()

"""#Rename The Columns"""

data.columns

data.columns=['id','age','blood_pressure','specific_gravity','albumin','sugar','red_blood_cell','pus_cells','pus_cells_clumps','bacteria','blood glucose random','blood_urea','serum_creatinie','sodiam','potassium','hemoglobin','packed_cell_volume','white_blood_cell_count','red_blood_cell_count','hypertention','diabetesmellites','coronary_artery_disease','appetite','pedal_edema','anemia','class']

data.columns

"""#Handling Missing Values

"""

data.info()

data.isnull().any()

data['blood glucose random'].fillna(data['blood glucose random'].mean(),inplace=True)
data['blood_pressure'].fillna(data['blood_pressure'].mean(),inplace=True)
data['blood_urea'].fillna(data['blood_urea'].mean(),inplace=True)
data['hemoglobin'].fillna(data['hemoglobin'].mean(),inplace=True)
data['packed_cell_volume'].fillna(data['packed_cell_volume'].mean(),inplace=True)
data['potassium'].fillna(data['potassium'].mean(),inplace=True)
data['red_blood_cell_count'].fillna(data['red_blood_cell_count'].mean(),inplace=True)
data['serum_creatinine'].fillna(data['serum_creatinine'].mean(),inplace=True)
data['sodium'].fillna(data['sodium'].mean(),inplace=True)
data['white_blood_cell_count'].fillna(data['white_blood_cell_count'].mean(),inplace=True)

data['age'].fillna(data['age'].mode()[0],inplace=True)
data['hyper_tension'].fillna(data['hyper_tension'].mode()[0],inplace=True)
data['pus_cells_clumps'].fillna(data['pus_cells_clumps'].mode()[0],inplace=True)
data['appetite'].fillna(data['appetite'].mode()[0],inplace=True)
data['albumin'].fillna(data['albumin'].mode()[0],inplace=True)
data['pus_cell'].fillna(data['pus_cell'].mode()[0],inplace=True)
data['red_blood_cells'].fillna(data['red_blood_cells'].mode()[0],inplace=True)
data['coronary_artery_disease'].fillna(data['coronary_artery_disease'].mode()[0],inplace=True)
data['bacteria'].fillna(data['bacteria'].mode()[0],inplace=True)
data['anemia'].fillna(data['anemia'].mode()[0],inplace=True)
data['sugar'].fillna(data['sugar'].mode()[0],inplace=True)
data['diabetesmellitus'].fillna(data['diabetesmellitus'].mode()[0],inplace=True)
data['pedal_edema'].fillna(data['pedal_edema'].mode()[0],inplace=True)
data['specific_gravity'].fillna(data['specific_gravity'].mode()[0],inplace=True)

"""#Handling Categorical Columns"""

cantcols=set(data.dtypes[data.dtypes=='0'].index.values)
print(cantcols)

for i in cantcols:
    print("columns:",i)
    print(c(data[i]))
    print('*'*120+'\n')

cantcols.remove('red_blood_cells_count')
cantcols.remove('packed_cell_volume')
cantcols.remove('white_blood_cell_count')
print(cantcols)

"""#Labeling Encoding For Categorical Columns"""

carcols=['anemia','pedal_edema','appetite','bacteria','class','coronary_artery_disease','diabetesmettit','hypertension','pus_cell','pus_cell_clumps','red_blood_cells']

from sklearn.preprocessing import LabelEncoder
for i in cantcols:
    print("LABEL ENCODING OF:",i)
    LEi = LabelEncoder()
    print(c(data[i]))
    data[i] = LEi.fit_trasform(data[i])
    print(c(data[i]))
    print("*"*100)

"""#Handling Numerical columns """

contcols=set(data.dtypes[data.dtypes!='0'].index.values)
print(contcols)

for i in contcols:
    print("continous columns :",i)
    print(c(data[i]))
    print('*'*120+'\n')

contcols.remove('specific_gravity')
contcols.remove('albumin')
contcols.remove('sugar')
print(contcols)

contcols.add('red_blood_cell_count')
contcols.add('packed_cell_volume')
contcols.add('white_blood_cells')
print(contcols)

contcols.remove('specific_gravity')
contcols.remove('albumin')
contcols.remove('sugar')
print(contcols)

data['coronary_artery_disease']=data.coronary_artery_diesease.replace('\tno,no')
c(data['coronary_artery_disease'])

data['diabetesmellitus'] = data.diabetesmellitus.replace(to_replace={'\tno':'no','\tpes':'yes','yes':})
c(data['diabetesmellitus'])

"""#task 3

#descriptive statistical analysis
"""

data.describe()

"""#Visual Analysis"""

sns.distplot(data.age)

"""#Bivariate Analysis"""

import matplotlib.pyplot as plt 
fig=plt.figure(figsize=(5,5))
plt.scatter(data['age'],data['blood_pressure'],color='blue')
plt.xlable('age')
plt.ylable('blood_pressure')
plt.tittle('age vs blood scatter plot')

"""#Multivariate Analysis"""

plt.figure(figsize=(20,15),facecolor='white')
plotnumber = 1
for coloumn in contcols :
  ax = plt.subplot(3,4,plotnumber)
  plt.scatter(data['age'],data[coloumn])
  plt.xlable(sodium,fontsize=30)
plotnumber+=1
plt.show()

"""#task 4

#Model Builing
"""

!pip install matplotlib-venn
import classification
from classification.keras.models import classification
from classification.keras.models import classification
import tensorflow
from tensorflow.keras.models import sequencial
from tensorflow.keras.layers import Dense

classification= sequencial()
classification.add(dense(30,activation='relu'))
classification.add(dense(128,activation='relu'))
classification.add(dense(64,activation='relu'))
classification.add(dense(32,activation='relu'))
classification.add(dense(1,activation='sigmoid'))

classification.fit(x_train,y_train,batch_size=10,validation_split=0.2,epochs=100)

"""#Random Forest Model

"""

from sklearn.ensemble import RandomForestClassifier
rfc = RandomForestClassifier(n_estimators=10,criterion='entropy')

rfc.fit(x_train,y_train)

y_predict = rfc.predict(x_test)
y_predict_train = rfc.predict(x_train)

"""#Decision Tree Model"""

from sklearn.tree import DecisionTreeClassifier
dtc = decisionTreeClassifier(max_depth=4,spliter='best',criterion='entropy')
dtc.fit(x_train,y_train)
DecisionTreeClassifier(criterion='entropy',max_depth=4)
y_predict_train = dtc.predict(x_train)

"""#Logistic Regreesion"""

from sklearn.lenear_model import LogisticRegression
lgr = logisticRegression ()
lgr.fit(x_train,y_train)
LgisticRegression()
#predicting our output with the model which we build
from sklearn.meterials import accuracy_source,classification_report
y_predict = lgr.predict(x_test)

"""#Testing The Model"""

y_pred = lgr.predict([[1,1,121.000000,36.0,0,0,0,1,0]])
print(y_pred)
(y_pred)
[0]
arry([0])
y_pred = lgr.predict([[1,1,121.000000,36.0,0,0,0,1,0]])
print(y_pred)
(y_pred)
[0]
arry([0])

classification.save("ckd.h5")
y_pred=classification.predict(x_test)
y_pred

y_pred = (y_pred > 0.5)
y_pred

def predict_exit(sample_value):
  sample_value = np.array(sample_value)
  sample_value = sample_value.reshape(1,-1)
  sample_value = sc.transform(sample_value)
  return classifier.predict(sample_value)
  test=classification.predict([[1,1,121.000000,36.0,0,0,1,0]])
  if test ==1:
    print('prediction:High chance of CKDI')
  else:
    print('prediction: Low chance of CKD')

  prediction: Low chance of CKD

"""#TASK 5

#Performence Testing & Evaluate the Results

#Testing Model
"""

from sklearn import model_selection

from os import name
from sklearn.exceptions import FitFailedWarning
KFold,
dfs = []
models = [
          ('LogReg',LogisticRegression()),
          ('RF',RandomForestclassifier()),
          ('DecisionTree',DecisionTreeClassifier()),
         ] 
results = []
names = []
scoring = ['accuracy','precision_weighted','recall_weighted','f1_weighted','roc_auc']
target_name = ['NO CKD','CKD']
for name,model in models:
           Kfold = model_selection.KFold(n_splits=5,shuffle=true,random_state=90210)
           CV_results = model_selection.cross_validate(model,x_train,y_train,cv=kfold,scoring=scoring)
           clf = model.Fit(x_train,y_train)
           y_pred = clf.predict(x_test)
           print(name)
           print(classification_report(y_test,y_pred,target_names=target_names))
           results.append(cv_results)
           names.append(name)
           this_df = pd.dataframe(cv_results)
           this_df['model'] = name
           dfs.append(this_df)
final = pd.concat(dfs,ignore_index=true)
return final

from sklearn.mertics import confusion_matrix
cm = confusion_matrix(y_test,y_predict)
cm

plt.plt.figure(figsize=(8,6))
sns.heatmap(cm,cmap='blues',annot=true,xticklabels=['no ckd','ckd'],yticklabels=['no ckd','ckd'])
plt.xlabel('predicted values')
plt.ylabel('actual value')
plt.title('confusion matrix for logistic regression model')
plt.show()

from sklearn.metrics import confusion_matrix
cm-confusion_matrix(y_test,y_predict)
cm

plt.figure(figsize-(8,6))
sns.heatmap(cm,cmap-'blues',annot-true,xticklabels=['no ckd','ckd'],yticklabels=['no ckd''ckd'])
plt.xlabel('predicted values')
plt.ylabel('Actual values')
plt.title('confusion matrix for randomforestclassifier')
plt.show()

from sklearn.metrics import confusion_matrix
cm = confusion_matrix(y_test,y_predict)
cm

plt.figure(figsize=(8,6))
sns.heatmap(cm,cmap='Blues',annot=true,xtricklabels=['no ckd','ckd'],yticklabels=['no ckd','ckd'])
plt.xlabel('predicted values')
plt.ylabel('Actual values')
plt.title('confusion matrix for DecisionTreeClassifier')
plt.show()

from sklearn.metrics import confusion_matrix
cm = confusion_matrix(y_test,y_pred)
cm

plt.figure(figsize=(8,6))
sns.heatmap(cm,cmap='Blues',annot=True,xticklabels=['no ckd','ckd'],yticklabels=['no ckd','ckd'])
plt.xlabel('predicted values')
plt.ylabel('Actual values')
plt.title('confusion matrix for ANN model')
plt.show()

"""#Evaluate the Result"""

bootstraps = []
for model in list(set(final.model.values)):
    model_df = final.loc[final.model == model] 
    bootstrap = model_df.sample(n=30,replace=true) 
    bootstraps.append(bootstrap)
bootstrap_df = pd.concat(bootstraps,igore_index=true)  
results_long = pd.melt(bootstrap_df,id_vars=['model'],var_name='metrcs',value_name='values')
time_metrics = ['fit_time','score_time']# fit time matrics
## PERFORMANCE METRICS
results_long_nofit = results_long.loc[~results_long['metrics'].isin(time_metrics)]# get df without fit data
results_long_nofit = results_long_nofit.sort_values(by='values')
## TIME METRICS
results_long_fit = results_long.loc[results_long['metrics'].isin(time_metrics)] # df with fit data
results_long_fit = results_long_fit.sort_values(by='values')

import matplotlip.pyplot as plt
import seaborn as sns
plt.figure(figsize=(20,12))
sns.set(font_scale=2.5)
g = sns.boxplot(x="model",y="values",hue="metrics",data=result_long_nofit,palette="set3")
plt.legend(bbox_to_anchor=(1.05,1),loc=2,borderaxespad=0.)
plt.title('comparison of model by classificartion metric')
plt.savefig('./benchmark_models_performance.png',dpi=300)

"""#TASK 6"""

pickle.dump(lgr, open('CKD.pkl','wb'))

from flask import flask,render_template,request
import numpy as np
import pickle

app = flask(_name_) # initializing a flask app
model = pickle.load(open('CKD.pkl','rb')) # loading the model

@app.route('/') # route to display the home page
def home():
    return render_template('home.html') # rendering the home page

@app.route('/prediction',methods=['POST','GET'])
def prediction():
    return render_template('indexnew.html')
@app.route('/Home',methods=['POST','GET'])
def my_home():
    return render_template('home.html')
@app.route('/predict',methods=['POST']) # route to show the predictions in a web UI
def predict():
    #reading the inouts given by the user
    input_features = [float(x) for x in request.form.values()]
    features_values = [np.array(input_features)]
    features_name = ['blood_urea','blood glucose random','anemia',
                     'coronary_artery_disease','pus_cell','red_blood_cells',
                     'diabetesmellitus','pedal_edema']
    df = pd.Dataframe(features_value,columns=features_name)
    # predictions using the loaded model file
    output = model.predict(df)

# showing the prediction results in a UI# showing the prediction results in a UI
return render_template('results.html',prediction_text=output)

if_name_=='_main_'
   # running the app
app.run(debug=true)